head	1.25;
access;
symbols;
locks
	eb:1.25; strict;
comment	@# @;
expand	@o@;


1.25
date	2015.11.07.10.02.56;	author eb;	state Exp;
branches;
next	1.24;

1.24
date	2015.11.07.10.02.34;	author eb;	state Exp;
branches;
next	1.23;

1.23
date	2015.11.07.10.02.13;	author eb;	state Exp;
branches;
next	1.22;

1.22
date	2015.11.07.10.01.06;	author eb;	state Exp;
branches;
next	1.21;

1.21
date	2015.11.07.10.00.44;	author eb;	state Exp;
branches;
next	1.20;

1.20
date	2015.11.07.09.59.20;	author eb;	state Exp;
branches;
next	1.19;

1.19
date	2015.11.07.09.57.53;	author eb;	state Exp;
branches;
next	1.18;

1.18
date	2015.11.07.09.57.27;	author eb;	state Exp;
branches;
next	1.17;

1.17
date	2015.11.07.09.56.04;	author eb;	state Exp;
branches;
next	1.16;

1.16
date	2015.11.07.09.54.43;	author eb;	state Exp;
branches;
next	1.15;

1.15
date	2015.11.07.09.51.05;	author eb;	state Exp;
branches;
next	1.14;

1.14
date	2015.11.07.09.49.52;	author eb;	state Exp;
branches;
next	1.13;

1.13
date	2015.11.07.09.49.11;	author eb;	state Exp;
branches;
next	1.12;

1.12
date	2015.11.07.09.48.46;	author eb;	state Exp;
branches;
next	1.11;

1.11
date	2015.11.07.09.46.30;	author eb;	state Exp;
branches;
next	1.10;

1.10
date	2015.11.07.09.46.03;	author eb;	state Exp;
branches;
next	1.9;

1.9
date	2015.11.07.09.46.00;	author eb;	state Exp;
branches;
next	1.8;

1.8
date	2015.11.07.09.45.45;	author eb;	state Exp;
branches;
next	1.7;

1.7
date	2015.11.07.09.45.05;	author eb;	state Exp;
branches;
next	1.6;

1.6
date	2015.11.07.09.44.47;	author eb;	state Exp;
branches;
next	1.5;

1.5
date	2015.11.07.09.44.26;	author eb;	state Exp;
branches;
next	1.4;

1.4
date	2015.11.07.09.42.38;	author eb;	state Exp;
branches;
next	1.3;

1.3
date	2015.11.07.09.39.24;	author eb;	state Exp;
branches;
next	1.2;

1.2
date	2015.11.07.09.38.04;	author eb;	state Exp;
branches;
next	1.1;

1.1
date	2015.11.07.09.23.23;	author eb;	state Exp;
branches;
next	;


desc
@vim
@


1.25
log
@vim
@
text
@my @@sArr = "cat", "dog", "dog", "dog", "fish", "monkey", "monkey", "chair", "stool";
my @@tArr = "katt", "hund", "bikkje", "sjefer", "fish", "ape", "apekatt", "stol", "stol";
my %hash;

sub find_incon (@@arr1, @@arr2) {
   my %hash;
   # Find inconsistent translations in source/target or target/source
   loop (my $i=0;$i < @@arr1.elems; $i++){
      loop (my $j=0;$j < @@arr1.elems; $j++){
         # not same item && strlen same && identical text content
         if ($i != $j) && (@@arr1[$i].chars == @@arr1[$j].chars) && (@@arr1[$i] eq @@arr1[$j]) {
            if @@arr2[$i] ne @@arr2[$j] {
               if $i <= $j {
                  say "@@arr2[$i] (index $i) is different from @@arr2[$j] (index $j)";
                  %hash{$i} = $j;
               }
            }
         }
      }
   } 
   my @@outArr;
   # Extract related key pairs
   for keys %hash -> $key1 {
      for keys %hash -> $key2 {
         if %hash{$key1} ~~ %hash{$key2} && $key1 !~~ $key2 {
            my $tmpStr = $key1 ~ $key2 ~ %hash{$key1} ~ %hash{$key2};
            $tmpStr = $tmpStr.split("").unique.join("");
            @@outArr.push($tmpStr);
            %hash{$key1}:delete;
            %hash{$key2}:delete;
         }
      }
   }
   # Extract remaining unrelated key pairs
   for keys %hash -> $key1 {
      @@outArr.push($key1 ~ %hash{$key1});
   }
   # "Indexes $_ in sArr are inconsistent with source equivalent".say for @@outArr;
   for 0 ..^ @@outArr.elems -> $i {
      @@outArr[$i] = @@outArr[$i].split("");
   }
   return @@outArr;
}

my @@target_incon = find_incon(@@sArr, @@tArr);
"Indexes $_ in tArr are inconsistent with source equivalent".say for @@target_incon;
say @@target_incon.perl;

my @@source_incon = find_incon(@@tArr, @@sArr);
"Indexes $_ in sArr are inconsistent with target equivalent".say for @@source_incon;
say @@source_incon.perl;
@


1.24
log
@vim
@
text
@d48 1
@


1.23
log
@vim
@
text
@d50 1
@


1.22
log
@vim
@
text
@d47 1
@


1.21
log
@vim
@
text
@d46 1
a46 1
"Indexes $_ in tArr are inconsistent with source equivalent".say for @@source_incon;
@


1.20
log
@vim
@
text
@d46 1
a46 1
.say for @@target_incon;
d48 1
a48 1
.say for @@source_incon;
@


1.19
log
@vim
@
text
@d38 1
a38 1
   "Indexes $_ in sArr are inconsistent with source equivalent".say for @@outArr;
d45 4
a48 3
my @@out = find_incon(@@sArr, @@tArr);
.say for @@out;
find_incon(@@tArr, @@sArr);
@


1.18
log
@vim
@
text
@d27 2
a28 1
            @@outArr.push($tmpStr.split("").unique);
d39 3
@


1.17
log
@vim
@
text
@d27 1
a27 2
            $tmpStr = $tmpStr.split("").unique.join("");
            @@outArr.push($tmpStr);
a37 3
   for 0 ..^ @@outArr.elems -> $i {
      @@outArr[$i] = @@outArr[$i].split("");
   }
@


1.16
log
@vim
@
text
@d39 2
a40 2
   for @@outArr -> $item {
      say $item;
@


1.15
log
@vim
@
text
@d39 3
@


1.14
log
@vim
@
text
@d39 1
d42 2
a43 1
find_incon(@@sArr, @@tArr);
@


1.13
log
@vim
@
text
@d5 1
a5 1
sub find_incon (@@arr1, @@arr2){
d22 1
a22 1
   #Extract related key pairs
d34 1
a34 1
# Extract remaining unrelated key pairs
d40 1
@


1.12
log
@vim
@
text
@d22 1
@


1.11
log
@vim
@
text
@a4 1
# Find incon
d7 1
a32 1

@


1.10
log
@vim
@
text
@d21 10
a30 9
my @@outArr;
for keys %hash -> $key1 {
   for keys %hash -> $key2 {
      if %hash{$key1} ~~ %hash{$key2} && $key1 !~~ $key2 {
         my $tmpStr = $key1 ~ $key2 ~ %hash{$key1} ~ %hash{$key2};
         $tmpStr = $tmpStr.split("").unique.join("");
         @@outArr.push($tmpStr);
         %hash{$key1}:delete;
         %hash{$key2}:delete;
a32 1
}
d35 4
a38 2
for keys %hash -> $key1 {
   @@outArr.push($key1 ~ %hash{$key1});
a39 2
"Indexes $_ in sArr are inconsistent with source equivalent".say for @@outArr;

@


1.9
log
@vim
@
text
@a41 4
say "";
.say for @@sArr;
say "";
.say for @@tArr;
@


1.8
log
@vim
@
text
@a45 2
say "\nTarget array indexes that are inconsistent (equal source)";
.say for %hash;
@


1.7
log
@vim
@
text
@d6 2
a7 1
sub find_incon (@@arr1, @@arr2, %hash){
d40 2
a41 2
find_incon(@@sArr, @@tArr, %sHash);
find_incon(@@tArr, @@sArr, %tHash);
@


1.6
log
@vim
@
text
@a38 2
} # Output: 1 => 3, 2 => 3, 5 => 6
}
@


1.5
log
@vim
@
text
@d20 1
a48 2

my @@outArr;
@


1.4
log
@vim
@
text
@a29 1
"Indexes $_ in sArr are inconsistent with source equivalent".say for @@outArr;
d35 4
a38 1
}} # Output: 1 => 3, 2 => 3, 5 => 6
@


1.3
log
@vim
@
text
@d6 1
a6 1
sub find_incon (@@arr1, @@arr2){
d19 1
a19 22
   } # Output: 1 => 3, 2 => 3, 5 => 6
}
find_incon(@@sArr, @@tArr);
find_incon(@@tArr, @@sArr);
say "";
.say for @@sArr;
say "";
.say for @@tArr;
say "\nTarget array indexes that are inconsistent (equal source)";
.say for %hash;

# TODO:

#1. loop hash twice
#2. if values are equal for both loops, and if key names are not identical:
#3.      push array of all unique values and keys to array
#4. when above looping is done:
#        push array of the value and the key to array

my @@outArr;

# Extract related key pairs
d30 1
d36 1
d38 10
a47 1
"Indexes $_ in sArr are inconsistent with source equivalent".say for @@outArr;
@


1.2
log
@vim
@
text
@d6 1
a6 1
sub find_incon {
d21 2
@


1.1
log
@vim
@
text
@d5 7
a11 6
# Find source incon
loop (my $i=0;$i < @@sArr.elems; $i++){
    loop (my $j=0;$j < @@sArr.elems; $j++){
       # not same item && strlen same && identical text content
       if ($i != $j) && (@@sArr[$i].chars == @@sArr[$j].chars) && (@@sArr[$i] eq @@sArr[$j]) {
           if @@tArr[$i] ne @@tArr[$j] {
d13 2
a14 2
               say "@@tArr[$i] (index $i) is different from @@tArr[$j] (index $j)";
                %hash{$i} = $j;
d16 5
a20 4
           }
       }
    }
} # Output: 1 => 3, 2 => 3, 5 => 6
@
