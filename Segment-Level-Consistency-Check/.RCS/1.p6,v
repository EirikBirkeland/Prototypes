head	1.59;
access;
symbols;
locks
	eb:1.59; strict;
comment	@# @;
expand	@o@;


1.59
date	2015.11.07.09.56.46;	author eb;	state Exp;
branches;
next	1.58;

1.58
date	2015.11.07.09.22.41;	author eb;	state Exp;
branches;
next	1.57;

1.57
date	2015.11.07.09.22.07;	author eb;	state Exp;
branches;
next	1.56;

1.56
date	2015.11.07.09.21.10;	author eb;	state Exp;
branches;
next	1.55;

1.55
date	2015.11.07.09.21.07;	author eb;	state Exp;
branches;
next	1.54;

1.54
date	2015.11.07.09.20.53;	author eb;	state Exp;
branches;
next	1.53;

1.53
date	2015.11.07.09.20.23;	author eb;	state Exp;
branches;
next	1.52;

1.52
date	2015.11.07.09.20.07;	author eb;	state Exp;
branches;
next	1.51;

1.51
date	2015.11.07.09.18.54;	author eb;	state Exp;
branches;
next	1.50;

1.50
date	2015.11.07.09.17.22;	author eb;	state Exp;
branches;
next	1.49;

1.49
date	2015.11.07.09.17.11;	author eb;	state Exp;
branches;
next	1.48;

1.48
date	2015.11.07.09.16.57;	author eb;	state Exp;
branches;
next	1.47;

1.47
date	2015.11.07.09.15.59;	author eb;	state Exp;
branches;
next	1.46;

1.46
date	2015.11.07.09.15.35;	author eb;	state Exp;
branches;
next	1.45;

1.45
date	2015.11.07.09.15.14;	author eb;	state Exp;
branches;
next	1.44;

1.44
date	2015.11.07.09.14.39;	author eb;	state Exp;
branches;
next	1.43;

1.43
date	2015.11.07.09.13.12;	author eb;	state Exp;
branches;
next	1.42;

1.42
date	2015.11.07.09.12.07;	author eb;	state Exp;
branches;
next	1.41;

1.41
date	2015.11.07.09.11.45;	author eb;	state Exp;
branches;
next	1.40;

1.40
date	2015.11.07.09.10.42;	author eb;	state Exp;
branches;
next	1.39;

1.39
date	2015.11.07.09.10.01;	author eb;	state Exp;
branches;
next	1.38;

1.38
date	2015.11.07.09.09.38;	author eb;	state Exp;
branches;
next	1.37;

1.37
date	2015.11.07.09.05.07;	author eb;	state Exp;
branches;
next	1.36;

1.36
date	2015.11.07.08.53.04;	author eb;	state Exp;
branches;
next	1.35;

1.35
date	2015.11.07.08.50.57;	author eb;	state Exp;
branches;
next	1.34;

1.34
date	2015.11.07.08.50.08;	author eb;	state Exp;
branches;
next	1.33;

1.33
date	2015.11.07.08.49.47;	author eb;	state Exp;
branches;
next	1.32;

1.32
date	2015.11.07.08.47.53;	author eb;	state Exp;
branches;
next	1.31;

1.31
date	2015.11.06.21.50.56;	author eb;	state Exp;
branches;
next	1.30;

1.30
date	2015.11.06.21.49.59;	author eb;	state Exp;
branches;
next	1.29;

1.29
date	2015.11.06.21.48.54;	author eb;	state Exp;
branches;
next	1.28;

1.28
date	2015.11.06.21.46.44;	author eb;	state Exp;
branches;
next	1.27;

1.27
date	2015.11.06.21.46.08;	author eb;	state Exp;
branches;
next	1.26;

1.26
date	2015.11.06.21.45.45;	author eb;	state Exp;
branches;
next	1.25;

1.25
date	2015.11.06.21.41.15;	author eb;	state Exp;
branches;
next	1.24;

1.24
date	2015.11.06.21.32.52;	author eb;	state Exp;
branches;
next	1.23;

1.23
date	2015.11.06.21.32.28;	author eb;	state Exp;
branches;
next	1.22;

1.22
date	2015.11.06.21.31.32;	author eb;	state Exp;
branches;
next	1.21;

1.21
date	2015.11.06.21.28.46;	author eb;	state Exp;
branches;
next	1.20;

1.20
date	2015.11.06.21.26.52;	author eb;	state Exp;
branches;
next	1.19;

1.19
date	2015.11.06.21.26.23;	author eb;	state Exp;
branches;
next	1.18;

1.18
date	2015.11.06.21.24.57;	author eb;	state Exp;
branches;
next	1.17;

1.17
date	2015.11.06.21.23.38;	author eb;	state Exp;
branches;
next	1.16;

1.16
date	2015.11.06.21.23.27;	author eb;	state Exp;
branches;
next	1.15;

1.15
date	2015.11.06.21.22.45;	author eb;	state Exp;
branches;
next	1.14;

1.14
date	2015.11.06.21.21.38;	author eb;	state Exp;
branches;
next	1.13;

1.13
date	2015.11.06.21.21.22;	author eb;	state Exp;
branches;
next	1.12;

1.12
date	2015.11.06.21.21.02;	author eb;	state Exp;
branches;
next	1.11;

1.11
date	2015.11.06.21.13.27;	author eb;	state Exp;
branches;
next	1.10;

1.10
date	2015.11.06.21.11.35;	author eb;	state Exp;
branches;
next	1.9;

1.9
date	2015.11.06.21.10.47;	author eb;	state Exp;
branches;
next	1.8;

1.8
date	2015.11.06.21.10.21;	author eb;	state Exp;
branches;
next	1.7;

1.7
date	2015.11.06.21.09.58;	author eb;	state Exp;
branches;
next	1.6;

1.6
date	2015.11.06.21.08.00;	author eb;	state Exp;
branches;
next	1.5;

1.5
date	2015.11.06.21.07.02;	author eb;	state Exp;
branches;
next	1.4;

1.4
date	2015.11.06.21.03.44;	author eb;	state Exp;
branches;
next	1.3;

1.3
date	2015.11.06.21.03.20;	author eb;	state Exp;
branches;
next	1.2;

1.2
date	2015.11.06.21.03.05;	author eb;	state Exp;
branches;
next	1.1;

1.1
date	2015.11.06.19.30.20;	author eb;	state Exp;
branches;
next	;


desc
@vim
@


1.59
log
@vim
@
text
@my @@sArr = "cat", "dog", "dog", "dog", "fish", "monkey", "monkey", "chair", "stool";
my @@tArr = "katt", "hund", "bikkje", "sjefer", "fish", "ape", "apekatt", "stol", "stol";
my %hash;

# Find source incon
loop (my $i=0;$i < @@sArr.elems; $i++){
    loop (my $j=0;$j < @@sArr.elems; $j++){
       # not same item && strlen same && identical text content
       if ($i != $j) && (@@sArr[$i].chars == @@sArr[$j].chars) && (@@sArr[$i] eq @@sArr[$j]) {
           if @@tArr[$i] ne @@tArr[$j] {
               if $i <= $j {
               say "@@tArr[$i] (index $i) is different from @@tArr[$j] (index $j)";
                %hash{$i} = $j;
               }
           }
       }
    }
} # Output: 1 => 3, 2 => 3, 5 => 6
say "";
.say for @@sArr;
say "";
.say for @@tArr;
say "\nTarget array indexes that are inconsistent (equal source)";
.say for %hash;

# TODO:

#1. loop hash twice
#2. if values are equal for both loops, and if key names are not identical:
#3.      push array of all unique values and keys to array
#4. when above looping is done:
#        push array of the value and the key to array

my @@outArr;

# Extract related key pairs
for keys %hash -> $key1 {
   for keys %hash -> $key2 {
      if %hash{$key1} ~~ %hash{$key2} && $key1 !~~ $key2 {
         my $tmpStr = $key1 ~ $key2 ~ %hash{$key1} ~ %hash{$key2};
         @@outArr.push($tmpStr.split("").unique);
         %hash{$key1}:delete;
         %hash{$key2}:delete;
      }
   }
}

# Extract remaining unrelated key pairs
for keys %hash -> $key1 {
   @@outArr.push($key1 ~ %hash{$key1});
}
"Indexes $_ in sArr are inconsistent with source equivalent".say for @@outArr;
@


1.58
log
@vim
@
text
@d41 1
a41 2
         $tmpStr = $tmpStr.split("").unique.join("");
         @@outArr.push($tmpStr);
@


1.57
log
@vim
@
text
@d53 1
a53 1
"Hello".say for @@outArr;
@


1.56
log
@vim
@
text
@d53 1
a53 1
.say for @@outArr;
@


1.55
log
@vim
@
text
@a40 1
         say $tmpStr;
@


1.54
log
@vim
@
text
@d43 1
a43 2
         say $tmpStr;
         @@outArr.push();
@


1.53
log
@vim
@
text
@d41 1
d43 1
@


1.52
log
@vim
@
text
@d41 1
a41 1
         $tmpStr = $tmpStr.split("").uniq.join("");
@


1.51
log
@vim
@
text
@d41 1
a41 1
         $tmpStr = $tmpStr.split.uniq.join;
@


1.50
log
@vim
@
text
@d41 2
a42 1
         @@outArr.push($tmpStr.subst(/(\d)$1/, "$1", :g));
@


1.49
log
@vim
@
text
@d41 1
a41 1
         @@outArr.push($tmpStr.subst(/(\d)\1/, $1, :g));
@


1.48
log
@vim
@
text
@d41 1
a41 1
         @@outArr.push($tmpStr.subst(/(\d)$1/, $1, :g));
@


1.47
log
@vim
@
text
@d41 1
a41 1
         @@outArr.push($tmpStr.subst(/(0-9)$1/, $1, :g));
@


1.46
log
@vim
@
text
@d41 1
a41 1
         @@outArr.push($tmpStr.subst(/([0-9])$1/, $1, :g));
@


1.45
log
@vim
@
text
@d41 1
a41 1
         @@outArr.push($tmpStr.subst(/(\w)$1/, $1, :g));
@


1.44
log
@vim
@
text
@d41 1
a41 1
         @@outArr.push($tmpStr.subst(/(\w)$1/, "$1", :g));
@


1.43
log
@vim
@
text
@d41 1
a41 1
         @@outArr.push($tmpStr.subst(/(\w)$1/$1));
@


1.42
log
@vim
@
text
@d41 1
a41 1
         @@outArr.push($tmpStr.subst(/(\w)$1/$1:g/));
@


1.41
log
@vim
@
text
@d41 1
a41 1
         @@outArr.push($tmpStr.subst(/(\w)$1/$1:g));
@


1.40
log
@vim
@
text
@d40 2
a41 1
         @@outArr.push(($key1 ~ $key2 ~ %hash{$key1} ~ %hash{$key2}).subst(/(\w)$1/$1:g));
@


1.39
log
@vim
@
text
@d40 1
a40 1
         @@outArr.push(($key1 ~ $key2 ~ %hash{$key1} ~ %hash{$key2}).subst(/(\w)$1/$1:g/);
@


1.38
log
@vim
@
text
@d40 1
a40 1
         @@outArr.push(($key1 ~ $key2 ~ %hash{$key1} ~ %hash{$key2}).subst(/(\w)$1/$1:g);
@


1.37
log
@vim
@
text
@d40 1
a40 1
         @@outArr.push(($key1 ~ $key2 ~ %hash{$key1} ~ %hash{$key2}).subst(/(\w)\1/$1:g);
@


1.36
log
@vim
@
text
@d35 2
d40 1
a40 1
         @@outArr.push($key1 ~ $key2 ~ %hash{$key1} ~ %hash{$key2});
d46 2
@


1.35
log
@vim
@
text
@d39 2
a40 2
      } else {
         @@outArr.push($key1 ~ $key2 ~ %hash{$key1} ~ %hash{$key2});
d43 3
@


1.34
log
@vim
@
text
@d39 2
@


1.33
log
@vim
@
text
@d37 1
a37 1
      if %hash{$key1} ~~ %hash{$key2} && $key1 !~ $key2 {
@


1.32
log
@vim
@
text
@d37 1
a37 1
      if %hash{$key1} ~~ %hash{$key2} && $key1 ~~ $key2 {
@


1.31
log
@vim
@
text
@d37 1
a37 1
      if %hash{$key1} ~~ %hash{$key2} {
@


1.30
log
@vim
@
text
@d37 1
a37 1
      if $key1 ~~ $key2 {
@


1.29
log
@vim
@
text
@d38 1
a38 1
         @@outArr = $key1 ~ $key2 ~ %hash{$key1} ~ %hash{$key2};
@


1.28
log
@vim
@
text
@d35 2
a36 2
for keys values %hash -> $key1 $val1 {
   for keys values %hash -> $key2 $val2 {
d38 1
a38 1
         @@outArr = $key1 ~ $key2 ~ $val1 ~ $val2;
@


1.27
log
@vim
@
text
@d35 2
a36 2
for keys values %hash -> $key1, $val1 {
   for keys values %hash -> $key2, $val2 {
@


1.26
log
@vim
@
text
@d28 5
a32 5
1. loop hash twice
2. if values are equal for both loops, and if key names are not identical:
3.      push array of all unique values and keys to array
4. when above looping is done:
        push array of the value and the key to array
@


1.25
log
@vim
@
text
@d34 6
a39 3
for keys %hash -> $key1 {
   for keys %hash -> $key2 {

d42 1
@


1.24
log
@vim
@
text
@d28 11
a38 3
1.
2.
3.
@


1.23
log
@vim
@
text
@d26 5
a30 1
# TODO: 1. 2. 3.
@


1.22
log
@vim
@
text
@d26 1
a26 13
# TODO: Maybe scratch this:

my @@tmpArr;
my $tmpStr;

for keys %hash -> $key1 { # 1 2 5
   $tmpStr = $key1;
   for values %hash -> $key2 { # 3 3 6
      $tmpStr ~= ($tmpStr ~~ /$key1/ ?? "" !! $key1);
      $tmpStr ~= ($tmpStr ~~ /$key2/ ?? "" !! $key2);
   }
say $tmpStr;
}
@


1.21
log
@vim
@
text
@d31 1
a31 1
for keys %hash -> $key1 {
d33 1
a33 1
   for values %hash -> $key2 {
@


1.20
log
@vim
@
text
@d18 1
a18 1
}
@


1.19
log
@vim
@
text
@d5 1
a5 1
# Source incon
@


1.18
log
@vim
@
text
@d26 2
@


1.17
log
@vim
@
text
@d30 1
a30 1
   # $tmpStr = "";
@


1.16
log
@vim
@
text
@d31 1
a31 1
   for value %hash -> $key2 {
@


1.15
log
@vim
@
text
@d31 1
a31 1
   for keys %hash -> $key2 {
@


1.14
log
@vim
@
text
@d28 1
@


1.13
log
@vim
@
text
@d34 1
a35 1
say $tmpStr;
@


1.12
log
@vim
@
text
@d31 1
a31 1
      $tmpStr ~= ($pStr ~~ /$key1/ ?? "" !! $key1);
@


1.11
log
@vim
@
text
@d31 2
a32 2
      $tmpStr ~= ($tmpStr ~~ $key1 ?? "" !! $key1);
      $tmpStr ~= ($tmpStr ~~ $key2 ?? "" !! $key2);
d35 1
a35 1
   say $tmpStr;
@


1.10
log
@vim
@
text
@d32 1
@


1.9
log
@vim
@
text
@d29 1
a29 1
   $tmpStr = "";
d33 1
a34 1
}
@


1.8
log
@vim
@
text
@d31 1
a31 1
      $tmpStr =~ ($tmpStr ~~ $key1 ?? "" !! $key1);
@


1.7
log
@vim
@
text
@d31 1
a31 1
      $tmpStr =~ $tmpStr ~~ $key1 ?? "" !! $key1;
@


1.6
log
@vim
@
text
@d31 1
a31 1
      $tmpStr =~ $tmpStr !~ $key1 ?? $key1 ;
@


1.5
log
@vim
@
text
@d31 1
a31 1
      $tmpStr =~ $tmpStr !~ $key1 == $key1 ;
@


1.4
log
@vim
@
text
@d27 1
d29 1
a29 1
   @@tmpArr = "";
d31 1
a31 1
      @@tmpArr ~= $key1;
d33 1
a33 1
   say @@tmpArr;
@


1.3
log
@vim
@
text
@d26 1
a26 2
my @@dupArr;
my $tmpArr;
@


1.2
log
@vim
@
text
@d31 1
a31 1
      @@tmparr ~= $key1;
@


1.1
log
@vim
@
text
@d27 1
a27 1
my $tmpStr;
@
